#!/usr/bin/env python3
"""
Comparison tool to check if OCR numeric outputs match ground truth transcriptions.
Compares only the numeric values, ignoring units (e.g., "575kpa" vs "575psi" both match for "575").
Compares transcription files generated by inference_all.py with spec_dict.json files.
"""

import os
import json
import re
import argparse
import yaml
import sys
from collections import Counter, defaultdict
from pathlib import Path


class OutputCapture:
    """Capture print output to both console and a log file."""
    
    def __init__(self, log_file=None):
        self.log_file = log_file
        self.log_content = []
        
    def print(self, *args, **kwargs):
        """Print to console and capture to log."""
        # Print to console
        print(*args, **kwargs)
        
        # Capture to log
        if self.log_file:
            # Convert print arguments to string like print() does
            sep = kwargs.get('sep', ' ')
            end = kwargs.get('end', '\n')
            output = sep.join(str(arg) for arg in args) + end
            self.log_content.append(output)
    
    def save_log(self):
        """Save captured output to log file."""
        if self.log_file and self.log_content:
            try:
                with open(self.log_file, 'w', encoding='utf-8') as f:
                    f.writelines(self.log_content)
                return True
            except Exception as e:
                print(f"WARNING: Failed to save log file: {e}")
                return False
        return False


def extract_numbers_from_text(text, expected_patterns=None):
    """
    Extract just the numeric values from text, ignoring units.
    Used for transcription text where units may be mis-transcribed.
    
    Strategy:
    1. Find numbers that appear with any unit or standalone
    2. Handle OCR errors in numbers (s ↔ 5 confusion)
    3. Return just the numeric values for comparison
    
    Handles common OCR errors:
    - 5 ↔ s confusion (e.g., "s7s" → "575", "14s0" → "1450")
    
    Returns normalized numeric values: ["1450", "3195", "575", "83"]
    """
    if not text:
        return []
    
    # Convert to lowercase for case-insensitive matching
    text = text.lower()
    
    # Extract all numbers (with or without units) - flexible for transcriptions
    return extract_all_numbers(text)


def extract_ground_truth_numbers_with_units(text):
    """
    Extract numbers with units from ground truth text using the reliable algorithm.
    This uses the same extraction logic as the original compare.py for consistent results.
    """
    if not text:
        return []
    
    # Convert to lowercase for case-insensitive matching
    text = text.lower()
    
    # Use the reliable connected pattern extraction for ground truth
    return extract_connected_numbers_units(text)


def extract_connected_numbers_units(text):
    """
    Extract numbers with units using regex patterns for both connected and spaced text.
    This is the same reliable algorithm from the original compare.py.
    """
    
    # Patterns for different number formats with units (both connected and with spaces)
    patterns = [
        # Connected patterns (no spaces) - exact digits only
        r'\b(\d+(?:\.\d+)?)kg\b',      # kg (e.g., 1450kg)
        r'\b(\d+(?:\.\d+)?)lbs?\b',    # lbs/lb (e.g., 3000lbs)
        r'\b(\d+(?:\.\d+)?)kpa\b',     # kPa (e.g., 575kpa)
        r'\b(\d+(?:\.\d+)?)psi\b',     # PSI (e.g., 83psi)
        r'\b(\d+(?:\.\d+)?)ps1\b',     # PS1 (OCR error for PSI)
        
        # Spaced patterns (with spaces) - exact digits only
        r'\b(\d+(?:\.\d+)?)\s+kg\b',      # kg with space (e.g., 1450 kg)
        r'\b(\d+(?:\.\d+)?)\s+lbs?\b',    # lbs/lb with space (e.g., 3000 lbs)
        r'\b(\d+(?:\.\d+)?)\s+kpa\b',     # kPa with space (e.g., 575 kpa)
        r'\b(\d+(?:\.\d+)?)\s+psi\b',     # PSI with space (e.g., 83 psi)
        r'\b(\d+(?:\.\d+)?)\s+ps1\b',     # PS1 with space (OCR error for PSI)
        
        # OCR confusion patterns: 5 ↔ s (allow s at any position in number) - connected
        r'\b([s\d]*[s\d]+(?:\.\d+)?)kg\b',      # kg with 's' instead of '5' (e.g., 14s0kg, s60kg, 1s60kg)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)lbs?\b',    # lbs with 's' instead of '5' (e.g., 319slbs, s000lbs)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)kpa\b',     # kPa with 's' instead of '5' (e.g., s7skpa, 57skpa)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)psi\b',     # PSI with 's' instead of '5' (e.g., 8spsi, s3psi)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)ps1\b',     # PS1 with 's' instead of '5'
        
        # OCR confusion patterns: 5 ↔ s (allow s at any position in number) - spaced
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+kg\b',      # kg with 's' instead of '5' and space (e.g., 14s0 kg)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+lbs?\b',    # lbs with 's' instead of '5' and space (e.g., 319s lbs)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+kpa\b',     # kPa with 's' instead of '5' and space (e.g., s7s kpa)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+psi\b',     # PSI with 's' instead of '5' and space (e.g., 8s psi)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+ps1\b',     # PS1 with 's' instead of '5' and space
        
        # OCR confusion patterns: 5 ↔ s in units themselves - connected
        r'\b(\d+(?:\.\d+)?)p5i\b',     # P5I (OCR error for PSI: 5 instead of S)
        r'\b(\d+(?:\.\d+)?)p51\b',     # P51 (OCR error for PSI: 5 instead of S, 1 instead of I)
        r'\b(\d+(?:\.\d+)?)lb5\b',     # lb5 (OCR error for lbs: 5 instead of s)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)p5i\b',     # P5I with 's' in number
        r'\b([s\d]*[s\d]+(?:\.\d+)?)p51\b',     # P51 with 's' in number
        r'\b([s\d]*[s\d]+(?:\.\d+)?)lb5\b',     # lb5 with 's' in number
        
        # OCR confusion patterns: 5 ↔ s in units themselves - spaced
        r'\b(\d+(?:\.\d+)?)\s+p5i\b',     # P5I with space (OCR error for PSI: 5 instead of S)
        r'\b(\d+(?:\.\d+)?)\s+p51\b',     # P51 with space (OCR error for PSI: 5 instead of S, 1 instead of I)
        r'\b(\d+(?:\.\d+)?)\s+lb5\b',     # lb5 with space (OCR error for lbs: 5 instead of s)
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+p5i\b',     # P5I with 's' in number and space
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+p51\b',     # P51 with 's' in number and space
        r'\b([s\d]*[s\d]+(?:\.\d+)?)\s+lb5\b',     # lb5 with 's' in number and space
    ]

    found_numbers = []
    matched_positions = set()  # Track what we've already matched
    
    for pattern in patterns:
        matches = re.finditer(pattern, text)  # Use finditer to get positions
        for match_obj in matches:
            match_text = match_obj.group(1)
            start_pos = match_obj.start()
            end_pos = match_obj.end()
            
            # Skip if this position range overlaps with already matched text
            position_range = set(range(start_pos, end_pos))
            if position_range & matched_positions:
                continue
            
            # Skip matches that are purely letters (like "s" or "ss")
            if match_text.replace('.', '').isalpha():
                continue
                
            # Normalize 's' to '5' in the matched number
            normalized_match = match_text.replace('s', '5')
            
            # Skip if the result doesn't look like a valid number
            try:
                # Test if it's a valid number after conversion
                num_value = float(normalized_match)
                # Convert to integer string if it's a whole number
                if num_value == int(num_value):
                    found_numbers.append(str(int(num_value)))
                else:
                    found_numbers.append(str(num_value))
            except ValueError:
                continue
            
            # Mark this position as matched
            matched_positions.update(position_range)
    
    return found_numbers


def extract_all_numbers(text):
    """
    Extract all numeric values from text, handling OCR errors and ignoring units.
    Returns list of normalized numeric strings.
    """
    if not text:
        return []
    
    # Patterns to match numbers (with or without any text following them)
    patterns = [
        # Numbers directly connected to letters only (no digits in units)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)[a-z]+\b',
        
        # Numbers followed by a single space and then letters only
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\s[a-z]+\b',
        
        # Handle specific OCR errors where letters in units become digits (like ps1, p51, etc.)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)ps1\b',  # ps1 (OCR error for psi)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)p51\b',  # p51 (OCR error for psi)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)p5i\b',  # p5i (OCR error for psi)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)lb5\b',  # lb5 (OCR error for lbs)
        
        # Handle spaced OCR errors
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\s+ps1\b',  # spaced ps1
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\s+p51\b',  # spaced p51
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\s+p5i\b',  # spaced p5i
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\s+lb5\b',  # spaced lb5
        
        # Standalone numbers (not followed by any letters or specific OCR errors)
        r'\b([s\d]*\d[s\d]*(?:\.\d+)?)\b(?!\s*[a-z])',
    ]
    
    found_numbers = []
    matched_positions = set()
    
    for pattern in patterns:
        matches = re.finditer(pattern, text.lower())
        for match_obj in matches:
            match_text = match_obj.group(1)
            start_pos = match_obj.start()
            end_pos = match_obj.end()
            
            # Skip if this position overlaps with already matched text
            position_range = set(range(start_pos, end_pos))
            if position_range & matched_positions:
                continue
            
            # Skip matches that are purely letters
            if match_text.replace('.', '').isalpha():
                continue
                
            # Normalize 's' to '5'
            normalized_match = match_text.replace('s', '5')
            
            # Validate it's a number after normalization
            try:
                num_value = float(normalized_match)
                # Convert back to string, removing unnecessary decimal places
                if num_value == int(num_value):
                    found_numbers.append(str(int(num_value)))
                else:
                    found_numbers.append(str(num_value))
                matched_positions.update(position_range)
            except ValueError:
                continue
    
    return found_numbers


def extract_ground_truth_numbers(json_data):
    """Extract numeric values from JSON ground truth data using reliable algorithm."""
    all_text = ""
    for key, value in json_data.items():
        if isinstance(value, str):
            all_text += " " + value
    
    # Use the reliable extraction method for ground truth, but return only numbers
    return extract_ground_truth_numbers_with_units(all_text)


def parse_transcription_file(file_path):
    """Parse a transcription file and extract detected text with scores."""
    transcriptions = []
    if not os.path.exists(file_path):
        return transcriptions
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line:
                    # Parse format: 'text' (score: 0.xxx)
                    match = re.match(r"'([^']+)'\s*\(score:\s*([\d.]+)\)", line)
                    if match:
                        text = match.group(1)
                        score = float(match.group(2))
                        transcriptions.append((text, score))
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
    
    return transcriptions


def compare_folder(input_folder, output_folder, output_capture=None):
    """Compare OCR results for a single folder against ground truth."""
    # Use output_capture if provided, otherwise use regular print
    out = output_capture if output_capture else type('', (), {'print': print})()
    
    out.print(f"\n=== Analyzing folder: {os.path.basename(input_folder)} ===")
    
    # Read ground truth JSON
    json_path = os.path.join(input_folder, "spec_dict.json")
    if not os.path.exists(json_path):
        out.print(f"ERROR: Ground truth JSON not found at {json_path}")
        return None
    
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            ground_truth = json.load(f)
    except Exception as e:
        out.print(f"ERROR: Failed to read JSON file {json_path}: {e}")
        return None
    
    # Extract ground truth numbers (just numeric values)
    gt_numbers = extract_ground_truth_numbers(ground_truth)
    gt_counter = Counter(gt_numbers)
    out.print(f"Ground truth numbers: {dict(gt_counter)}")

    # Process each transcription file
    transcription_files = [
        "center_img_transcription.txt",
        "left_img_transcription.txt", 
        "material_img_transcription.txt",
        "right_img_transcription.txt"
    ]
    
    all_detected_numbers = []
    results = {}
    
    for trans_file in transcription_files:
        trans_path = os.path.join(output_folder, trans_file)
        transcriptions = parse_transcription_file(trans_path)
        
        # Extract numbers from all transcribed text (just numeric values)
        detected_text = " ".join([text for text, score in transcriptions])
        detected_numbers = extract_numbers_from_text(detected_text)
        all_detected_numbers.extend(detected_numbers)
        
        results[trans_file] = {
            'transcriptions': transcriptions,
            'detected_numbers': detected_numbers
        }
        
        out.print(f"\n{trans_file}:")
        out.print(f"  Transcribed text: {[text for text, score in transcriptions]}")
        out.print(f"  Detected numbers: {detected_numbers}")
    
    # Compare overall results
    detected_counter = Counter(all_detected_numbers)
    out.print(f"\nDetected numbers (all files): {dict(detected_counter)}")
    
    # Check for matches and misses
    out.print(f"\n--- Comparison Results (Numbers Only) ---")
    all_correct = True
    
    for number, expected_count in gt_counter.items():
        detected_count = detected_counter.get(number, 0)
        if detected_count >= expected_count:  # Allow more detections than expected
            out.print(f"✓ {number}: Expected {expected_count}, Found {detected_count}")
        else:
            out.print(f"✗ {number}: Expected {expected_count}, Found {detected_count}")
            all_correct = False
    
    # Don't penalize for extra detections - they're just noise from material text
    extra_detections = []
    for number, detected_count in detected_counter.items():
        if number not in gt_counter:
            extra_detections.append(f"{number} (found {detected_count} times)")
    
    if extra_detections:
        out.print(f"ℹ Extra detections (ignored): {', '.join(extra_detections)}")
    
    return {
        'folder': os.path.basename(input_folder),
        'ground_truth': dict(gt_counter),
        'detected': dict(detected_counter),
        'all_correct': all_correct,
        'details': results
    }


def load_config(config_path):
    """Load configuration from YAML file."""
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        return config
    except Exception as e:
        print(f"Error loading config file {config_path}: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(description="Compare OCR numeric outputs with ground truth (numbers only, ignoring units)")
    parser.add_argument('--config', '-c', default='comparetools/config.yaml',
                       help='Path to configuration YAML file (default: comparetools/config.yaml)')
    parser.add_argument('--input-base', 
                       help='Base directory containing input folders (overrides config)')
    parser.add_argument('--output-base',
                       help='Base directory containing output folders (overrides config)')
    parser.add_argument('--folder', help='Specific folder to analyze (overrides config)')
    
    args = parser.parse_args()
    
    # Load configuration
    config = load_config(args.config)
    if config is None:
        print(f"Failed to load config file: {args.config}")
        print("Please check the file exists and is valid YAML.")
        return
    
    # Setup output capture if detailed report is requested
    output_capture = None
    if config.get('save_detailed_report', False):
        log_file = config.get('log_file', 'comparison_log.txt')
        output_capture = OutputCapture(log_file)
        out = output_capture
    else:
        # Create a simple object that just uses regular print
        out = type('', (), {'print': print})()
    
    # Command line arguments override config file
    input_base_path = args.input_base or config.get('input_base')
    output_base_path = args.output_base or config.get('output_base')
    specific_folder = args.folder or config.get('folder', '')
    
    if not input_base_path:
        out.print("ERROR: input_base must be specified in config file or via --input-base")
        return
    
    if not output_base_path:
        out.print("ERROR: output_base must be specified in config file or via --output-base")
        return
    
    input_base = Path(input_base_path)
    output_base = Path(output_base_path)
    
    if not input_base.exists():
        out.print(f"ERROR: Input base directory does not exist: {input_base}")
        return
    
    if not output_base.exists():
        out.print(f"Output base directory does not exist: {output_base}")
        out.print("Creating output directory...")
        try:
            output_base.mkdir(parents=True, exist_ok=True)
            out.print(f"Created output directory: {output_base}")
        except Exception as e:
            out.print(f"ERROR: Failed to create output directory: {e}")
            return
        out.print()
    
    # Get list of folders to process
    if specific_folder:
        folders_to_process = [specific_folder]
    else:
        folders_to_process = [d.name for d in input_base.iterdir() if d.is_dir()]
    
    out.print(f"Using configuration from: {args.config}")
    out.print(f"Input base: {input_base}")
    out.print(f"Output base: {output_base}")
    if specific_folder:
        out.print(f"Processing single folder: {specific_folder}")
    out.print(f"Processing {len(folders_to_process)} folders...")
    out.print()
    
    overall_results = []
    correct_count = 0
    
    for folder_name in sorted(folders_to_process):
        input_folder = input_base / folder_name
        output_folder = output_base / folder_name
        
        if not input_folder.exists():
            out.print(f"WARNING: Input folder does not exist: {input_folder}")
            continue
            
        if not output_folder.exists():
            out.print(f"WARNING: Output folder does not exist: {output_folder}")
            continue
        
        result = compare_folder(str(input_folder), str(output_folder), output_capture)
        if result:
            overall_results.append(result)
            if result['all_correct']:
                correct_count += 1
    
    # Save detailed report if requested
    if config.get('save_detailed_report', False) and overall_results:
        report_file = config.get('report_file', 'comparison_report.json')
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(overall_results, f, indent=2, ensure_ascii=False)
            out.print(f"\nDetailed report saved to: {report_file}")
        except Exception as e:
            out.print(f"WARNING: Failed to save report: {e}")
    
    # Print summary
    out.print(f"\n{'='*60}")
    out.print(f"SUMMARY")
    out.print(f"{'='*60}")
    out.print(f"Total folders processed: {len(overall_results)}")
    out.print(f"Folders with all correct matches: {correct_count}")
    out.print(f"Accuracy: {correct_count}/{len(overall_results)} ({100*correct_count/len(overall_results):.1f}%)" if overall_results else "No results")
    
    # Print detailed results for incorrect folders
    incorrect_folders = [r for r in overall_results if not r['all_correct']]
    if incorrect_folders:
        out.print(f"\nFolders with incorrect matches:")
        for result in incorrect_folders:
            out.print(f"  - {result['folder']}")
            out.print(f"    Ground truth: {result['ground_truth']}")
            out.print(f"    Detected: {result['detected']}")
    
    # Save log file if output capture was used
    if output_capture and output_capture.save_log():
        log_file = config.get('log_file', 'comparison_log.txt')
        print(f"\nLog file saved to: {log_file}")


if __name__ == "__main__":
    main()
